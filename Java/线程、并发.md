## 一、线程状态

![img](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/ace830df-9919-48ca-91b5-60b193f593d2.png) 

### 新建（New）

创建后尚未启动。

### 可运行（Runnable）

可能正在运行，也可能正在等待 CPU 时间片。

包含了操作系统线程状态中的 Running 和 Ready。

### 阻塞（Blocking）

等待获取一个排它锁，如果其线程释放了锁就会结束此状态。

### 无限期等待（Waiting）

等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。

| 进入方法                                   | 退出方法                             |
| ------------------------------------------ | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
| LockSupport.park() 方法                    | -                                    |

### 限期等待（Timed Waiting）

无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。

调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。

| 进入方法                                 | 退出方法                                        |
| ---------------------------------------- | ----------------------------------------------- |
| Thread.sleep() 方法                      | 时间结束                                        |
| 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll() |
| 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕                 |
| LockSupport.parkNanos() 方法             | -                                               |
| LockSupport.parkUntil() 方法             | -                                               |

### 死亡（Terminated）

可以是线程结束任务之后自己结束，或者产生了异常而结束。
## 二、线程实现

- 通过实现 Runnable 接口，重写run方法。（建议使用，因为单继承多实现）
- 通过继承 Thread 类本身，重写run方法。
- 通过 Callable 和 Future（实现类FutureTask） 创建线程。

### 实现 Runnable 接口

需要实现 run() 方法。

通过 Thread 调用 start() 方法来启动线程。

```
public class MyRunnable implements Runnable {
    public void run() {
        // ...
    }
}
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
```

### 实现 Callable 接口

与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

可以通过**Future** 接口（1）判断任务是否完成--isDone()；（2）能够中断任务--cancel()；（3）能够获取任务执行结果--get()。 **FutureTask** 实现类可以将Callable转换成Future和Runnable，同时实现了两者的接口。

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
```

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
```

### 继承 Thread 类

同样也是需要实现 run() 方法，并且最后也是调用 start() 方法来启动线程。

```java
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
```

```java
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
```

### 实现接口 VS 继承 Thread

实现接口会更好，因为：

1. Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
2. 类可能只要求可执行就行，继承整个 Thread 类开销会过大。 

## 三、线程池

### 线程池结构

![img](https://images2015.cnblogs.com/blog/822071/201703/822071-20170323215428674-676355183.png) 

| Executor                                                  | ExecutorService                                              |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| Executor 是 Java 线程池的核心接口，用来并发执行提交的任务 | ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法 |
| 提供execute()方法用来提交任务                             | 提供submit()方法用来提交任务                                 |
| execute()方法无返回值                                     | submit()方法返回Future对象，可用来获取任务执行结果           |
| 不能取消任务                                              | 可以通过Future.cancel()取消pending中的任务                   |
| 没有提供和关闭线程池有关的方法                            | 提供了关闭线程池的方法                                       |

**Executors**是一个实现类，可以通过其创建线程池。



