## OSI参考模型和TCP/IP分层模型

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1528779329&di=d40a209d8fb0627156b3b4a782b99850&imgtype=jpg&er=1&src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-4fe0b5f06fc89af2f98ebd2690bc87ea_b.jpg) 

## IP及其相关协议

### IP协议

IP面向无连接，IP地址属于网络层地址，MAC地址是数据链路层的地址。

IP地址共32位，分为**网络地址**和**主机地址**两部分。网络地址用来标识唯一的网段，主机地址用来标识同一网段内唯一主机。**广播地址**指的是主机地址部分全为1的地址。

子网掩码：用于划分子网，标识出IP地址中的网络地址和主机地址部分。子网掩码也是32位，对应IP地址中网络部分的位全为1，主机部分全为0。

### DNS

将域名解析为服务器IP地址的协议。客户端从顶级域名开始一层层向域名服务器查询下一层域名地址。

### ARP

通过IP地址来定位MAC地址的协议。

**工作机制**：1.主机A通过广播发送ARP请求包，包中包含了想要了解MAC地址的主机的IP。2.与包中IP相匹配的主机B收到请求后，会返回包含了主机B的MAC地址的ARP响应给主机A。

### ICMP

功能包括确认IP包是否成功送达目标地址，通知在发送过程中IP包被废弃的具体原因，改善网络设置等。

### DHCP

自动设置IP地址，统一管理IP地址的分配，实现即插即用。

**工作机制**：首先需要架设一台DHCP服务器，然后将DHCP所要分配的IP地址、子网掩码、路由控制信息、DNS服务器地址等配置到该服务器上。1. 主机A广播DHCP发现包，要求设置IP地址和子网掩码。2. DHCP服务器响应DHCP提供包，通知可以使用的设置。3. 主机A广播DHCP请求包通知想要使用2中的设置。4. DHCP服务器响应DHCP提供包，通知允许3中的设置。

### NAT

将本地网络中的私有地址转换为全局IP地址。

## TCP与UDP

TCP是面向连接的，可靠的流协议。能够实行**顺序控制**或**重发控制**，同时具备**流量控制**、**拥塞控制**等功能。

TCP主要用于需要实现可靠性传输的，UDP则主要用于对高速传输和实时性有要求的通信，比如视频通话等。

**端口号**：用来标识不同的应用程序。常见端口 [ 22：ftp  22：ssh   80：http  443：https ]

## TCP

### 三次握手四次挥手

**ACK是标志位，ack是一个确认序号！！** 

（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![1528191808548](https://github.com/x18jinjz/Interview/tree/master/image/1528191808548.png)


（1）第一次挥手：Client发送一个FIN=1，seq=J（上一个最后传输的字节序号+1），用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
（2）第二次挥手：Server收到FIN后，发送一个ACK=1，ack=J+1给Client，Server进入CLOSE_WAIT状态。
（3）第三次挥手：Server发送一个FIN=1，ack=J+1，seq=K，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT_2状态，接着发送一个ACK给Server，seq=K+1，Server进入CLOSED状态，发送此报文后，Client等待2个msl时间后，也进入CLOSED状态。完成四次挥手。

![1528191812861](https://github.com/x18jinjz/Interview/tree/master/image/1528191812861.png)

**为什么TIME_WAIT 状态要等2MSL才进入CLOSED状态？**
MSL（Maximum Segment Lifetime）：报文最大生存时间，是任何报文段被丢弃前在网络内的最长时间。当主机1回复主机2的FIN后，等待(2-4分钟)，即使两端的应用程序结束。
如果主机1直接进入CLOSED状态，由于IP协议不可靠性或网络问题，导致主机1最后发出的ACK报文未被主机2接收到，那么主机2在超时后继续向主机1重新发送FIN，而主机1已经关闭，那么找不到向主机1发送FIN的连接，主机2这时收到RST并把错误报告给高层，不符合TCP协议的可靠性特点。

### 确认应答（ACK）和序列号

TCP通过**确认应答（ACK）**来实现可靠传输。当发送端将数据发出后会等待接收端的确认应答，如果收到确认应答，说明数据已经成功到达接收端。如果一定时间内没有收到ACK，则可以认为数据已丢失，进行重发。

然而，未收到ACK并不意味着数据一定丢失，也可能接收端已经收到数据，只是返回的ACK在途中丢失。因此采用了序列号保证可靠性。序列号是按顺序给发送数据的每一个字节标上编号（建立连接后随机数生成，初始值并非为0），接收端根据TCP首部中的序列号和数据的长度，将下一步要接受的序号作为确认应答号返回。

### 重发超时的确定

最理想的情况是找到一个最小时间，使得确认应答一定能在这个时间内返回。TCP会每次发包时计算往返时间RTT（Round Trip Time）和偏差，将往返时间和偏差相加，重发超时时间就是比这个值稍大一点的值。

![1528195484253](https://github.com/x18jinjz/Interview/tree/master/image/1528195484253.png)

### TCP以段为单位发送数据

TCP发送数据报的单位是最大消息长度MSS（Maximum Segment Size），MSS在三次握手的时候计算出来。两端主机发出建立连接请求时，都会在TCP首部中写入MSS，告知对方自己适应的MSS大小，然后会在两者之间选择一个较小的值使用。

### 窗口控制与重发控制

TCP以段为单位发送数据，每发一个段就需要进行一次确认应答处理，性能降低，因此引入了窗口的概念。确认应答以更大的单位进行确认，发送端在发送一个段后不必一直等待确认应答，而是继续发送。

![1528195906665](https://github.com/x18jinjz/Interview/tree/master/image/1528195906665.png)

![1528195919488](https://github.com/x18jinjz/Interview/tree/master/image/1528195919488.png)

窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，上图中窗口大小为4个段。

这个机制使用了大量的缓冲区。下图中白色区域为窗口部分，这个窗口内的数据即便没有收到确认应答也可以发送出去，因此有可能需要重发，所以必须在等到确认应答返回之前在缓冲区中保留这部分数据。当数据发出扣若如期收到确认应答，就可以将其移出缓冲区。收到确认应答的情况下，将窗口滑动到确认应答号的位置。

![1528197136784](https://github.com/x18jinjz/Interview/tree/master/image/1528197136784.png)

在使用窗口控制中，如果出现了段丢失的情况：1.确认应答未能返回的情况。2.数据段丢失的情况。

在确认应答未能返回的情况下，数据已经到达对端，不需要重发，如果使用了窗口控制，可以通过下一个确认应答来确认。

![1528197416314](https://github.com/x18jinjz/Interview/tree/master/image/1528197416314.png)

如果是数据段丢失，接收端接收到自己应该接受的序号以外的数据时，会针对当前位置收到的数据返回确认应答。因此发送端会重复收到丢失段前一个的确认应答，当连续3次收到同一个确认应答时，就会对相应数据进行重发（快重传机制）。

![1528198255523](https://github.com/x18jinjz/Interview/tree/master/image/1528198255523.png)

### 流量控制

TCP提供了一种可以让发送端根据接收端实际接收能力控制发送的数据量的机制，称为**流量控制**。

具体操作是，接收端在TCP首部中一个用来通知窗口大小的字段中写入自己可以接受数据的大小，发送端会发送不超过这个限度的数据，这个限度就是窗口大小。当接收端缓冲区满后，不得不暂时停止接收数据。之后在收到发送窗口更新通知后才得以继续通信。由于窗口更新通知有可能丢失，因此发送端主机会时不时发送一个叫做窗口探测的数据段，该数据段只包含一个字节以获取最新的窗口大小信息。

![1528198264833](https://github.com/x18jinjz/Interview/tree/master/image/1528198264833.png)

### 拥塞控制

在网络出现拥堵时，如果发送一个较大的数据，就可能使网络瘫痪。在通信刚开始时就发送大量数据，也可能引发其他问题。拥塞控制就是为了防止过多的数据注入到网络中。

**拥塞窗口**（cnwd）：发送方为一个动态变化的窗口叫做拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度。发送方让自己的发送窗口=拥塞窗口，但是发送窗口不是一直等于拥塞窗口的。在网络情况好的时候，拥塞窗口不断的增加，发送方的窗口自然也随着增加，但是接受方的接受能力有限，在发送方的窗口达到某个大小时就不在发生变化了。 

**慢启动思路**：在主机刚开始发送数据报的时候先探测一下网络的状况，如果网络状况良好，发送方每发送一次文段都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。 此时拥塞窗口成倍增长。

![1528201152331](https://github.com/x18jinjz/Interview/tree/master/image/1528201152331.png)

**拥塞避免**：由于慢启动时cwnd是成倍增长为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限值。 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。 慢开始门限值ssthresh的具体用法：

当cwnd<ssthresh时，使用慢开始算法。
当cwnd>ssthresh时，改用拥塞避免算法。
当cwnd=ssthresh时，慢开始与拥塞避免算法任意。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。

![1528202722966](https://github.com/x18jinjz/Interview/tree/master/image/1528202722966.png)

**快重传**： 快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 

![1528202842239](https://github.com/x18jinjz/Interview/tree/master/image/1528202842239.png)

**快恢复**： 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

![1528202934077](https://github.com/x18jinjz/Interview/tree/master/image/1528202934077.png)